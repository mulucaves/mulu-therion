encoding  utf-8
encoding  utf-8
# This file contains the settings used for the layout that ahould be common for the
# whole data set.
# The help with each command,comes from the Therion Book issued with v0.3.10
layout water-blue
  code metapost
  def a_water (expr p) =
    T:=identity;
    thfill p withcolor (0.0, 0.5, 1.0);
  enddef;  
endlayout

layout greyscale
  colour map-fg 100
  colour map-bg 85
endlayout

layout common
rotate 60
#scale 1 600
#Â• scale <picture length> <real length> . set scale of output map or map atlas (M,
#A; default: 1 200)

#base-scale 1 1
#Â• base-scale <picture length> <real length> . if set, Therion will optically scale
#the map by a (scale/base-scale) factor. This has the same effect as if the map
#printed in base-scale would be photoreduced to the scale. (M, A)

units metric
#Â• units <metric/imperial> . set output units (M, A; default: metric)

symbol-set BCRA
#symbol-set UIS
symbol-assign line gradient BCRA
#Mulu# needs to be disabled for the metacode to work
#Â• symbol-set <symbol-set> . use symbol-set for all map symbols, if available (M, A)
#Therion uses following predefined symbol sets:
#UIS (International Union of Speleology)
#ASF (Australian Speleological Federation)
#CCNP (Carlsbad Caverns National Park)
#SKBB (Speleoklub BanskÂ´a Bystrica)
#symbol-assign
#Â• symbol-assign <point/line/area/group/special> <symbol-type> <symbol-set>
#. display a particular symbol in the given symbol-set. This option overrides symbol-set
#option.
#If the symbol has a subtype, <symbol-type> argument may have one of the following
#forms: type:subtype or simply type, which assigns new symbol set to all subtypes of
#a given symbol.
#Following symbols may not be used with this option: point section (which isnÂ’t rendered
#at all) and all point and line labels (label, remark, altitude, height, passage-height,
#station-name, date). See the chapter Changing layout/Customizing text labels for details
#how to change labelsÂ’ appearance. (M, A)
#Group may be one of the following: all, centerline, sections.
#There are two special symbols: north-arrow, scale-bar.

symbol-hide group cave-centreline
#Â• symbol-hide <point/line/area/group/special> <symbol-type> . donÂ’t display
#particular symbol or group of symbols. You may use group cave-centerline, group
#surface-centerline, point cave-station and point surface-station in symbolhide
#and symbol-show commands. May be combined with symbol-show.(M, A)

#symbol-show <point/line/area/group/special> <symbol-type>
#Â• symbol-show <point/line/area/group/special> <symbol-type> . display particular
#symbol or group of symbols. May be combined with symbol-hide. (M, A)
#symbol-show point cave-station

#size <width> <height> <units>
#Â• size <width> <height> <units> . set map size in the atlas mode. If not specified, it
#will be calculated from page-setup and overlap. In map mode applies iff page-grid
#is on (M, A; default: 18 22.2 cm)

#overlap <value> <units>
#Â• overlap <value> <units> . set overlap size in paper units in the atlas mode or map
#margin in the map mode (M, A; default: 1 cm)

#page-setup <dimensions> <units>
#Â• page-setup <dimensions> <units> . set page dimensions in this order: paper-width,
#paper-height, page-width, page-height, left-margin and top-margin. If not specified, it
#will be computed from size and overlap (A; default: 21 29.7 20 28.7 0.5 0.5 cm)

#page-numbers <on/off>
#Â• page-numbers <on/off> . turn on/off page numbering (A; default: true)

#exclude-pages <on/off> <list>
#Â• exclude-pages <on/off> <list> . exclude specified pages from cave atlas. The list
#may contain page numbers separated by a comma or dash (for intervals) e.g. 2,4-
#7,9,23 means, that pages 2, 4, 5, 6, 7, 9 and 23 should be omitted. Only the map
#pages should be counted. (Set own-pages 0 and title-pages off to get the correct
#page numbers to be excluded.) Changes of own-pages or title-pages options donÂ’t
#affect page excluding. (A)

#title-pages <on/off>
#Â• title-pages <on/off> . turn on/off title pages before each atlas chapter (A; default:
#off)

#nav-factor <factor>
#Â• nav-factor <factor> . set atlas navigator zoom factor (A; default: 30)

#nav-size <x-size> <y-size>
#Â• nav-size <x-size> <y-size> . set number of atlas pages in both directions of navigator
#(A; default: 2 2)

transparency on
#Â• transparency <on/off> . set transparency for the passages (underlying passages are
#also visible) (M, A; default: on)

opacity 60
#Â• opacity <value> . set opacity value (used if transparency is on). Value range is
#0Â–100. (M, A; default: 70)

#surface <top/bottom/off>
#Â• surface-opacity <value> . set the surface bitmap opacity (used if transparency is
#on). Value range is 0Â–100. (M, A; default: 70)

#surface-opacity <value>
#Â• surface <top/bottom/off> . set the position of the surface bitmap above/below the
#map. (M, A; default: off)

layers on
#Â• layers <on/off> . enable/disable PDF 1.5 layers (M, A; default: on)

#grid bottom
#Â• grid <off/bottom/top> . enable/disable grid (M, A; default: off)

#grid-origin <x> <y> <x> <units>
#Â• grid-origin <x> <y> <x> <units> . set coordinates of grid origin (M, A) [Grid is
#currently not supported.]

grid-size 200 200 200 metres
#Â• grid-size <x> <y> <z> <units> . set grid size in real units (M, A; default 10 m)

#origin <x> <y> <z> <units>
#Â• origin <x> <y> <z> <units> . set origin of atlas pages (M, A)

#origin-label <x-label> <y-label>
#Â• origin-label <x-label> <y-label> . set label for atlas page which has the lower
#left corner at the given origin coordinates (M, A; default: 0 0)

#own-pages <number>
#Â• own-pages <number> . set number of own pages added before the first page of automatically
#generated pages in atlas mode (currently required for correct page numbering)
#(A; default: 0)

#page-grid <on/off>
#Â• page-grid <on/off> . show pages key plan (M; default: off)

legend on
#Â• legend <on/off/all> . display list of used map symbols in the map header. If set to
#all, all symbols from the current symbol set are displayed. (M, A; default: off)

#colour-legend <on/off>
#Â• colo[u]r-legend <on/off> . turn on/off colour legend (M, A)

#legend-columns <number>
#Â• legend-columns <number> . adjusts the number of legend columns (M, A; default: 2)

#legend-width <n> <units>
#Â• legend-width <n> <units> . legend width (M, A; default: 14 cm)

#map-header-bg <on/off>
#Â• map-header-bg <on/off> . when on, background of map header is filled with background
#colour (e.g. to hide map grid). (M; default: off)

map-header 0 -20 nw
#colour map-fg altitude
#  colour map-fg [40 50 10]
#  colour map-bg [15 50 25]


#statistics <explo/topo/carto/copyright all/off/number><explo/topo-length on/off>
#Â• statistics <explo/topo/carto/copyright all/off/number> or
#Â• statistics <explo/topo-length on/off> . display some basic statistics (M, A; default:off)
#statistics topo-length on
#statistics explo-length on
doc-author "Dave Clucas"

scale-bar 100 metres
#Â• scale-bar <length> <units> . set the length of the scale-bar (M, A)

#language <xx[_YY]>
#Â• language <xx[_YY]> . set output language. Available languages are listed on impressum
#page. See the Appendix if you want to add or customize translations. (M,A)
language en_UK

#Â• colo[u]r <item> <colour> . customize colour for special map items (map-fg, mapbg,
#preview-above, preview-below). Colour range is 0Â–100 for grayscale, [0Â–100 0Â–100
#0Â–100] triplet for RGB colours. Special colour specification for map-fg is altitude,
#scrap or map, in which case the map is coloured according to altitude, scraps or maps.

code metapost

  def l_contour(expr P)(text txt) =
   T:=identity;
   pickup PenD;
   thdraw P withcolor (0.5, 0 ,0);
   for pnt=txt:
     if (pnt=-2) or (pnt=-1):
       mark_(P,arctime(arclength(P)/2) of P, 0.2u);
     elseif pnt>=0:
       mark_(P,pnt,0.2*u);
     fi;
     exitif pnt<0;
   endfor;
  enddef;

   def p_u_gradient (expr P,R,S,A)=
     tmplength:=0.3u;
     if known ATTR_length: if ATTR_length="big": tmplength:=.4u;
     elseif ATTR_length="small": tmplength:=0.2u; fi;
     fi;
     U:=(.2u,.6u);
     T:=identity aligned A rotated R scaled S shifted P;
     thfill (-.1u,-tmplength)--(0,tmplength)--(.1u,-tmplength)--cycle;
    enddef;
    initsymbol("p_u");    

  def l_u_path  (expr P) =
    T:=identity;
    cas := 0;
    dlzka := arclength P;
    mojkrok := adjust_step(dlzka, 0.25u);
    pickup PenD;
    forever:
      t := arctime cas of P;
      thdraw ((point t of P) + 0.2 * u * unitvector(thdir(P,t) rotated 90)) --
        ((point t of P) - 0.2 * u * unitvector(thdir(P,t) rotated 90) );
    cas := cas + mojkrok;
    exitif cas > dlzka + (mojkrok/3);  % for rounding errors
    endfor;
    pickup PenC;
    %thdraw P; %draw path
  enddef;
  initsymbol("l_u_path");
  
  def l_u_cliff  (expr P) =
    T:=identity;
    cas := 0;
    dlzka := arclength P;
    mojkrok := adjust_step(dlzka, 0.8u);
    pickup PenD;
    forever:
      t := arctime cas of P;
      thdraw ((point t of P) + 0.4 * u * unitvector(thdir(P,t) rotated 75)) --
        ((point t of P) - 0.4 * u * unitvector(thdir(P,t) rotated 75) );
    cas := cas + mojkrok;
    exitif cas > dlzka + (mojkrok/3);  % for rounding errors
    endfor;
    pickup PenA;
    thdraw P; %draw path
  enddef;
  initsymbol("l_u_cliff");
  
  def a_u_river (expr p) =
    T:=identity;
    thclean p;
    thfill p withcolor (0.0, 1.0, 1.0);
  enddef;  
  initsymbol("a_u_river");

  fonts_setup(30,40,50,70,100);
#  fonts_setup(3,4,5,7,10);

def PenXXL = pencircle scaled (2.4*u/10) enddef;

vardef getdistance(expr A,B) =
 dx := xpart A - xpart B;
 dy := ypart A - ypart B;
 sqrt((dx,dy) dotprod (dx,dy))
enddef;

def l_u_river (expr Path) =
  T:=identity;
  pickup PenXXL;
  draw Path withcolor (0.0, 1.0, 1.0);
enddef;
initsymbol("l_u_river");
  
def l_u_pot (expr P) = 
 T:=identity;

 if cycle(P):
   pickup PenXXL;
  thdraw P;
  thclean P;
  pickup PenX;
  thdraw P;
  pickup PenC;
     thdraw P withcolor background;
     laenge:= arclength P;
  symsize:=0.5u;
   triangle_width:=symsize/2;

   pair l_triangle;
   pair f_triangle;
   pair test;
   path triangle;
   path draw_triangle;
   triangle:= (-triangle_width/2,0) -- (triangle_width/2,0) --
               (0,symsize/2) -- cycle;
   cur:=(symsize);

   t := arctime (cur) of P;
   f_triangle := (point t of P +.05u*unitvector(thdir(P,t) rotated 90));
   thfill triangle rotated angle thdir(P,t) shifted f_triangle ;
   l_triangle := f_triangle;

   for cur=(symsize) step 0.1 until laenge:
       t := arctime (cur) of P;
       test := (point t of P +.05u*unitvector(thdir(P,t) rotated 90));
       my_dist := getdistance(test,l_triangle);
      if abs(my_dist-symsize) < 0.05u:
          draw_triangle:=triangle rotated angle thdir(P,t) shifted test;
          if xpart (draw_triangle intersectiontimes P) < 0:
              thfill triangle rotated angle thdir(P,t) shifted test;
              l_triangle:= test;
          fi;
        fi;
    endfor;

 else: %path is not a cycle
   laenge:= arclength P;
   pickup PenC;
   pair pts[];
   path par;
   npts:=laenge/0.01u;
   for i = 0 upto npts:
        pts[i]=( 
             (point (arctime i/npts*laenge of P) of P) 
             + 0.125u*unitvector(thdir(P,(arctime i/npts*laenge of P)) rotated 90)
            );
  endfor;

   par = pts0
   for i = 0 upto npts:
        ..pts[i]
   endfor;

   thdraw par;
   laenge:= arclength par;
   symsize:=adjust_symbolsize(laenge,0.5u);
   symsize:=0.5u;
   triangle_width:=symsize/2;
   cur:=(symsize-triangle_width)/2;

   t1 := arctime (cur) of par;
   forever:

       t  := arctime (cur + triangle_width/2) of par;
       t2 := arctime (cur + triangle_width) of par;
       thfill (subpath (t1,t2) of par) -- 
         ((point t of par) + symsize/2 * unitvector(thdir(par,t) rotated 90)) -- 
         cycle;
       cur := cur + symsize;
       t1 := arctime (cur) of par;
       exitif cur >= laenge; % for rounding errors
   endfor;

   pickup PenA;
   thdraw P;
 fi;

enddef;

def l_u_doline (expr P) =
  T:=identity;
  cas := 0;
  dlzka := arclength P;
  mojkrok:=adjust_step(dlzka, 2u);
  pickup PenD;  
  forever:
    t := arctime cas of P;
    mark_ (P,t,2u);
    cas := cas + mojkrok;
    exitif cas > dlzka + (mojkrok / 3); % for rounding errors
  endfor;
  pickup PenC;  
  thdraw P withcolor (0.5, 0, 0);
enddef;

def l_contour(expr P)(text txt) =
  T:=identity;
  pickup PenD;
  thdraw P withcolor (0.5, 0, 0);
  for pnt=txt:
    if pnt=-2:
      mark_(P,arctime(arclength(P)/2) of P, 0.2u);
    elseif pnt>=0:
      mark_(P,pnt,0.2*u);
    fi;
    exitif pnt<0;
  endfor;
enddef;
def p_u_mud (expr pos,theta,sc,al)=
    U:=(.45u,.1u);
    T:=identity aligned al rotated theta scaled sc shifted pos;
    pickup PenC;
    p := ((-.15*u,0)--(.15*u,0));
    thdraw p shifted (.3u,-.1u);
    thdraw p shifted (-.3u,-.1u);
    thdraw p shifted (0,.1u);
enddef;

def l_u_mud (expr P) = 
  T:=identity;
  cas := 0;
  dlzka := arclength P;
  mojkrok:=adjust_step(dlzka, .5u);
  pickup PenC;
  q := (-0.15u,0){up}..{down}origin..{up}(0.15u,0);
  forever:
    t := arctime (cas + mojkrok/2) of P;
    thdraw q shifted (point t of P + .25u * unitvector(thdir(P,t) rotated -90));
    cas := cas + mojkrok;
    exitif cas > dlzka - (2*mojkrok/3); % for rounding errors
  endfor;
  pickup PenA;  
  thdraw P;
enddef;
def a_u_mud (expr p) =
  T:=identity;
  pickup PenC;
  path q, qq; q = bbox p;
  picture tmp_pic; 
  tmp_pic := image(
    for i = xpart llcorner q step 1.5u until xpart urcorner q:
      for j = ypart llcorner q step 1.5u until ypart urcorner q:
        qq := ((-.25u,0){up}..origin{down}..{up}(0.25u,0)) randomized (u/15)
             shifted ((i,j) randomized 1.3u);
	if xpart (p intersectiontimes qq) < 0:
	  thdraw qq;
	fi;
      endfor;  
    endfor;
  );
  clip tmp_pic to p;
  draw tmp_pic;
enddef;
initsymbol("p_u_mud");
initsymbol("l_u_mud");
initsymbol("a_u_mud");
initsymbol("l_u_contour");
initsymbol("l_u_doline");

code tex-map
  \legendcontent={%
  \hsize=\legendwidth
  \ifnortharrow\vbox to 0pt{\line{\hfil\northarrow}\vss}\fi
    \edef\tmp{\the\cavename} \ifx\tmp\empty \else
    {\size[26]\the\cavename} \vskip1cm
  \fi
  \ifscalebar\scalebar\vskip1cm\fi
  {\rightskip=0pt plus 3em\parskip=3bp
  \edef\tmp{\the\comment} 
  \ifx\tmp\empty \else
    {\size[12]\the\comment} \par\medskip
  \fi
  \everypar{\hangindent=2em\hangafter=1}   
  \edef\tmp{\the\cavelength} 
  \ifx\tmp\empty \else
    {\size[12]\si\the\cavelengthtitle: \ss\the\cavelength\par}
  \fi
  \edef\tmp{\the\cavedepth} \ifx\tmp\empty \else
    {\size[12]\si\the\cavedepthtitle: \ss\the\cavedepth\par}
  \fi
  \edef\tmp{\the\exploteam} 
  \ifx\tmp\empty \else
    {\size[12]\si\the\explotitle:
    \ss\the\exploteam\quad\si\the\explodate\par}
  \fi
  \edef\tmp{\the\topoteam} 
  \ifx\tmp\empty \else
   {\size[12]\si\the\topotitle: \ss\the\topoteam\quad\si\the\topodate\par}
  \fi
  \edef\tmp{\the\cartoteam} 
  \ifx\tmp\empty \else
    {\size[12]\si\the\cartotitle:
    \ss\the\cartoteam\quad\si\the\cartodate\par}
  \fi
  \edef\tmp{\the\copyrights} \ifx\tmp\empty \else
    {\size[12]\ss\the\copyrights\par}
  \fi
  }
  \formattedlegend 
}

endlayout
text en "point u:gradient" "gradient"
text en "line u:path" "plankwalk"
text en "line u:river" "surface river"
text en "line u:doline" "doline"
text en "line u:cliff" "cliff"
text en "point u:mud" "mud"



